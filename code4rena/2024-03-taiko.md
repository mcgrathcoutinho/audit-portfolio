# Taiko

![](https://pbs.twimg.com/profile_images/1664696448808615937/LQhJeOO__400x400.jpg)

## Scope

The code under review can be found within the [C4 Taiko repository](https://github.com/code-423n4/2024-03-taiko). 

## Summary

### [Findings](#findings-1)

| ID     | Issues                                                                                                                              | Severity       |
|--------|-------------------------------------------------------------------------------------------------------------------------------------|----------------|
| [H-01](#h-01-users-will-never-be-able-to-withdraw-their-claimed-airdrop-fully-in-erc20airdrop2sol-contract) | Users will never be able to withdraw their claimed airdrop fully in ERC20Airdrop2.sol contract                                      | High           |
| [H-02](#h-02-arbitrary-coinbase-address-can-be-supplied-by-malicious-block-proposer-to-use-up-another-proposers-allowance) | Arbitrary coinbase address can be supplied by malicious block proposer to use up another proposer's allowance                       | High           |
| [M-01](#m-01-incorrect-__essential_init-function-is-used-in-taikotoken-making-snapshooter-devoid-of-calling-snapshot) | Incorrect _Essentialinit() function is used in TaikoToken making snapshooter devoid of calling snapshot()                           | Medium         |
| [M-02](#m-02-banned-addresses-can-invokeexecute-message-call-through-retrymessage) | Banned addresses can invoke/execute message call through retryMessage()                                                             | Medium         |
| [L-01](#l-01-consider-initializing-contextupgradeable-contract-by-calling-__context_init-in-taikotokensol) | Consider initializing ContextUpgradeable contract by calling __Context_init() in TaikoToken.sol                                     | Low            |
| [L-02](#l-02-missing-address0-check-for-usdc-in-usdcadapter) | Missing address(0) check for USDC in USDCAdapter                                                                                    | Low            |
| [L-03](#l-03-__erc1155receiver_init-not-initialized-in-erc1155vault) | __ERC1155Receiver_init() not initialized in ERC1155Vault                                                                            | Low            |
| [L-04](#l-04-srctoken-and-srcchainid-is-not-updated-on-old-token-after-migration-through-changebridgedtoken) | srcToken and srcChainId is not updated on old token after migration through changeBridgedToken()                                    | Low            |
| [L-05](#l-05-merkleclaimable-does-not-check-if-claimstart-is-less-than-claimend) | MerkleClaimable does not check if claimStart is less than claimEnd                                                                  | Low            |
| [L-06](#l-06-if-amountunlocked-in-timelocktokenpool-is-less-than-1e18-rounding-down-occurs) | If amountUnlocked in TimelockTokenPool is less than 1e18, rounding down occurs                                                      | Low            |
| [L-07](#l-07-sendsignal-calls-can-be-spammed-by-attacker-to-relayer) | sendSignal() calls can be spammed by attacker to relayer                                                                            | Low            |
| [L-08](#l-08-consider-calling-ownable_init-function-in-constructor-to-prevent-frontrunning-of-initializer-functions-are-non-approved-attackers) | Consider calling Ownable_init() function in constructor to prevent frontrunning of initializer functions are non-approved attackers | Low            |
| [L-09](#l-09-add-zero-if-owner-will-process-themself-comment-to-gaslimit-instead-of-fee) | Add "Zero if owner will process themself" comment to gasLimit instead of fee                                                        | Low            |
| [L-10](#l-10-bridge-integration-issues-with-swapping-protocols) | Bridge integration issues with swapping protocols                                                                                   | Low            |
| [L-11](#l-11-sendmessage-does-not-check-if-status-is-equal-to-new) | sendMessage() does not check if STATUS is equal to NEW                                                                              | Low            |
| [L-12](#l-12-protocol-does-not-refund-extra-eth-but-implements-strict-check) | Protocol does not refund extra ETH but implements strict check                                                                      | Low            |
| [L-13](#l-13-if-a-message-is-suspended-before-processmessage-is-called-the-erc20-tokens-on-the-source-chain-and-ether-are-not-refunded) | If a message is suspended before processMessage() is called, the ERC20 tokens on the source chain and Ether are not refunded.       | Low            |
| [L-14](#l-14-user-loses-all-ether-if-their-address-is-blacklisted-on-canonical-token) | User loses all Ether if their address is blacklisted on canonical token                                                             | Low            |
| [L-15](#l-15-onmessageinvocation-checks-in-_invokemessagecall-can-be-bypassed-to-call-arbitrary-function-from-bridge-contract) | onMessageInvocation checks in _invokeMessageCall() can be bypassed to call arbitrary function from Bridge contract                  | Low            |
| [L-16](#l-16-consider-reading-return-value-from-snapshot-function) | Consider reading return value from snapshot() function                                                                              | Low            |
| [L-17](#l-17-one-off-error-in-block-sync-threshold-check-to-sync-chain-data) | One off error in block sync threshold check to sync chain data                                                                      | Low            |
| [L-18](#l-18-guardian-proof-that-is-never-fully-approved-by-minguardians-is-never-deleted) | Guardian proof that is never fully approved by minGuardians is never deleted                                                        | Low            |
| [L-19](#l-19-consider-making-the-timelock_admin_role-undergo-a-delay-when-transferring-the-admin-role) | Consider making the TIMELOCK_ADMIN_ROLE undergo a delay when transferring the admin role                                            | Low            |
| [L-20](#l-20-one-off-error-when-evaluating-deposits-to-process-with-the-ring-buffer-size) | One-off error when evaluating deposits to process with the ring buffer size                                                         | Low            |
| [L-21](#l-21-tokenuri-in-bridgederc721-does-not-conform-to-eip-721-specification) | tokenURI() in BridgedERC721 does not conform to EIP-721 specification                                                               | Low            |
| [L-22](#l-22-erc20vault-and-erc721vault-do-not-work-with-all-valid-erc20-and-erc721-compliant-tokens) | ERC20Vault and ERC721Vault do not work with all valid ERC20 and ERC721 compliant tokens                                             | Low            |
| [L-23](#l-23-guardians-cannot-be-fully-removed-from-the-system-which-can-compromise-the-integrity-of-the-protocol) | Guardians cannot be fully removed from the system which can compromise the integrity of the protocol                                | Low            |
| [R-01](#r-01-consider-implementing-changebridgedtoken-and-btokenblacklist-for-erc721vault-and-erc1155vault) | Consider implementing changeBridgedToken() and btokenBlacklist for ERC721Vault and ERC1155Vault                                     | Recommendation |
| [R-02](#r-02-instead-of-passing-an-empty-string-for-the-data-parameter-in-nft-vaults-on-token-transfers-allow-users-to-supply-data) | Instead of passing an empty string for the data parameter in NFT vaults on token transfers, allow users to supply data              | Recommendation |
| [R-03](#r-03-use-named-imports-to-improve-readability-of-the-code-and-avoid-polluting-the-global-namespace) | Use named imports to improve readability of the code and avoid polluting the global namespace                                       | Recommendation |
| [N-01](#n-01-avoid-hardcoding-data-in-bridgederc1155) | Avoid hardcoding data in BridgedERC1155                                                                                             | Non-Critical   |
| [N-02](#n-02-missing-sourcecanonical-function-on-bridgederc115-contract) | Missing source()/canonical() function on BridgedERC115 contract                                                                     | Non-Critical   |
| [N-03](#n-03-using-unchecked-arithmetic-in-for-loops-is-handled-by-solc-compiler-0822-onwards) | Using unchecked arithmetic in for loops is handled by solc compiler 0.8.22 onwards                                                  | Non-Critical   |
| [N-04](#n-04-typo-in-comment-in-bytessol) | Typo in comment in Bytes.sol                                                                                                        | Non-Critical   |
| [N-05](#n-05-incorrect-comment-regarding-gaslimit-in-processmessage) | Incorrect comment regarding gasLimit in processMessage()                                                                            | Non-Critical   |
| [N-06](#n-06-use-require-instead-of-assert) | Use require instead of assert                                                                                                       | Non-Critical   |
| [N-07](#n-06-use-require-instead-of-assert) | Incorrect natspec comment for proveMessageReceived()                                                                                | Non-Critical   |

### [Gas Optimizations](#gas-optimizations-1)

| ID     | Gas Optimizations                                                                                                          | Instances |
|--------|----------------------------------------------------------------------------------------------------------------------------|-----------|
| [G-01](#g-01-pack-structs-tightly-to-consume-less-slots-and-save-gas) | Pack structs tightly to consume less slots and save gas                                                                    | 2         |
| [G-02](#g-02-remove-blockcoinbase--address0-check-in-function-onblockproposed) | Remove block.coinbase != address(0) check in function onBlockProposed()                                                    | 1         |
| [G-03](#g-03-use-do-while-loop-instead-of-for-loop-to-save-gas) | Use do-while loop instead of for loop to save gas                                                                          | 7         |
| [G-04](#g-04-instead-of-accessing-deposits_iamount-consider-typecasting-data) | Instead of accessing `deposits_[i].amount` consider typecasting `data`                                                     | 1         |
| [G-05](#g-05-assigning-meta_txlistbyteoffset-to-0-not-required-due-to-default-value-being-0) | Assigning `meta_.txListByteOffset` to 0 not required due to default value being 0                                          | 1         |
| [G-06](#g-06-cache-_newguardianslength-to-save-gas) | Cache _newGuardians.length to save gas                                                                                     | 1         |
| [G-07](#g-07-instead-of-assigning-guardianslength-as-guardianid-use-i--1-to-save-gas) | Instead of assigning guardians.length as guardianId, use i + 1 to save gas                                                 | 1         |
| [G-08](#g-08-consider-removing-redundant-skipfeecheck-condition) | Consider removing redundant skipFeeCheck() condition                                                                       | 1         |
| [G-09](#g-09-remove-redundant-nonreentrant-modifier) | Remove redundant nonReentrant modifier                                                                                     | 1         |
| [G-10](#g-10-consider-adding-refundamount--0-check-to-save-gas-on-unnecessary-sendether-call) | Consider adding refundAmount > 0 check to save gas on unnecessary sendEther() call                                         | 1         |
| [G-11](#g-11-no-need-to-explicitly-set-success-variable-to-false-due-to-default-value-being-false) | No need to explicitly set success variable to false due to default value being false                                       | 1         |
| [G-12](#g-12-consider-using-if-else-block-instead-of-ternary-operators) | Consider using if-else block instead of ternary operators                                                                  | 2         |
| [G-13](#g-13-modifier-checks-not-required-on-function-_verfiyhopproof) | Modifier checks not required on function _verfiyHopProof()                                                                 | 1         |
| [G-14](#g-14-cache-optoken-in-function-_handlemessage-to-save-gas) | Cache op.token in function _handleMessage() to save gas                                                                    | 1         |
| [G-15](#g-15-consider-using-safebatchtransferfrom-instead-of-running-a-for-loop) | Consider using safeBatchTransferFrom() instead of running a for loop                                                       | 1         |
| [G-16](#g-16-add-a-check-on-source-chain-to-ensure-_opto-is-not-address0-or-destination-vault-to-save-full-cross-chain-execution-gas) | Add a check on source chain to ensure _op.to is not address(0) or destination vault to save full cross-chain execution gas | 1         |
| [G-17](#g-17-avoid-returning-unnecessary-64-bytes-in-libaddress-on-excessivelysafecall) | Avoid returning unnecessary 64 bytes in LibAddress on excessivelySafeCall()                                                | 1         |
| [G-18](#g-18-remove-redundant-string-memo-field-in-message-struct-to-save-1-slot) | Remove redundant string memo field in Message struct to save 1 slot                                                        | 1         |

### [Analysis Report](#analysis-report-1)

## Findings

## [H-01] Users will never be able to withdraw their claimed airdrop fully in ERC20Airdrop2.sol contract

### Impact
**Context:**
The ERC20Airdrop2.sol contract is for managing Taiko token airdrop for eligible users, but the withdrawal is not immediate and is subject to a withdrawal window.

Users can claim their tokens within claimStart and claimEnd. Once the claim window is over at claimEnd, they can withdraw their tokens between claimEnd and claimEnd + withdrawalWindow. During this withdrawal period, the tokens unlock linearly i.e. the tokens only become fully withdrawable at claimEnd + withdrawalWindow.

**Issue:**
The issue is that once the tokens for a user are fully unlocked, the [withdraw()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L88) function cannot be called anymore due to the [ongoingWithdrawals modifier](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39) having a strict `claimEnd + withdrawalWindow < block.timestamp` check in its second condition.

**Impact:**
Although the tokens become fully unlocked when block.timestamp = claimEnd + withdrawalWindow, it is extremely difficult or close to impossible for normal users to time this to get their full allocated claim amount. This means that users are always bound to lose certain amount of their eligible claim amount. This lost amount can be small for users who claim closer to claimEnd + withdrawalWindow and higher for those who partially claimed initially or did not claim at all thinking that they would claim once their tokens are fully unlocked.

### Proof of Concept

### Coded POC

How to use this POC:
- Add the POC to `test/team/airdrop/ERC20Airdrop2.t.sol`
- Run the POC using `forge test --match-test testAirdropIssue -vvv`
- The POC demonstrates how alice was only able to claim half her tokens out of her total 100 tokens claimable amount.
```solidity
     function testAirdropIssue() public {
       vm.warp(uint64(block.timestamp + 11));

       vm.prank(Alice, Alice);
       airdrop2.claim(Alice, 100, merkleProof);

       // Roll 5 days after
       vm.roll(block.number + 200);
       vm.warp(claimEnd + 5 days);

       airdrop2.withdraw(Alice);

       console.log("Alice balance:", token.balanceOf(Alice));

       // Roll 6 days after
       vm.roll(block.number + 200);
       vm.warp(claimEnd + 11 days);

       vm.expectRevert(ERC20Airdrop2.WITHDRAWALS_NOT_ONGOING.selector);
       airdrop2.withdraw(Alice);
   }
```

### Logs

```solidity
Logs:
 > MockERC20Airdrop @ 0x0000000000000000000000000000000000000000
   proxy      : 0xF62849F9A0B5Bf2913b396098F7c7019b51A820a
   impl       : 0x2e234DAe75C793f67A35089C9d99245E1C58470b
   owner      : 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496
   msg.sender : 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38
   this       : 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496
 Alice balance: 50
```

### Tools Used
Manual Review

### Recommended Mitigation Steps
In the [modifier ongoingWithdrawals()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC20Airdrop2.sol#L39), consider adding a buffer window in the second condition that gives users enough time to claim the fully unlocked tokens.

```solidity
   uint256 constant bufferWindow = X mins/hours/days;

   modifier ongoingWithdrawals() {
       if (claimEnd > block.timestamp || claimEnd + withdrawalWindow < block.timestamp + bufferWindow) {
           revert WITHDRAWALS_NOT_ONGOING();
       }
       _;
   }
```

## [H-02] Arbitrary coinbase address can be supplied by malicious block proposer to use up another proposer's allowance

### Impact
During block proposal, a block proposer is required to pay the prover their prover fee in Ether or an ERC20 fee token.

The issue with the current code is that a malicious block proposer could use another proposer's pre-approved allowance to the AssignmentHook.sol contract. This would allow the proposer to propose blocks with nothing at stake while the other block proposer falls victim to the stealing.

The issue has been marked as Medium-severity since although it is the proposer's responsibility to make atomic transactions (i.e. approve + propose), it is the protocol's responsibility to protect its users and attacks among block proposer's themselves in order to prevent a certain group of proposer's who do not delve deeper into learning the code. To better put it, we could think of [proposeBlock()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoL1.sol#L55) on TaikoL1 as a blackbox for the proposers.

### Proof of Concept

During block proposal, the functions are called as follows: [proposeBlock()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoL1.sol#L55) on TaikoL1 => [proposeBlock](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProposing.sol#L68) on LibProposing, which calls => the [onBlockProposed](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L61) function while looping through the hook.

The issue currently exists in the onBlockProposed function in the Assignment Hook contract. When the proposer pays the fee to the assigned prover, it requires the proposer to approve certain amount of tokens to the contract in order to allow it to transfer (see [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L114)).

A block proposer could frontrun the other block proposer's call once the approval is made and supply the coinbase address as the other block proposer's address. This allows the malicious block proposer to use up the tokens that were approved by the other proposer beforehand.


```solidity
File: AssignmentHook.sol
121:         // Find the prover fee using the minimal tier
122:         uint256 proverFee = _getProverFee(assignment.tierFees, _meta.minTier);
123:
124:         // The proposer irrevocably pays a fee to the assigned prover, either in
125:         // Ether or ERC20 tokens.
126:         if (assignment.feeToken == address(0)) {
127:             // Paying Ether
128:             _blk.assignedProver.sendEther(proverFee, MAX_GAS_PAYING_PROVER);
129:         } else {
130:             // Paying ERC20 tokens
131:             
132:             
133:             IERC20(assignment.feeToken).safeTransferFrom(
134:                 _meta.coinbase,
135:                 _blk.assignedProver,
136:                 proverFee
137:             );
```

### Tools Used
Manual Review

### Recommended Mitigation Steps
The simplest solution to this issue would be to pass the meta.coinbase address as the msg.sender.

## [M-01] Incorrect __Essential_init() function is used in TaikoToken making snapshooter devoid of calling snapshot()

### Impact
The EssentialContract.sol contract is inherited by the TaikoToken contract. This essential contract contains two __Essential_init() functions, one with an owner parameter only (see [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109)) and the other with owner and address manager parameters (see [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95)).

The issue with the current code is that it uses the [__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109) function with the owner parameter only. This would cause the [onlyFromOwnerOrNamed("snapshooter")](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) modifier on the [snapshot](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) function to not be able to resolve the snapshooter role since the address manager contract was never set during initialization, thus causing a revert.

Due to this:
1. Snapshooter role is denied from taking snapshots.
2. Timely snapshots for certain periods could have failed by the snapshooter since they would have required the owner to jump in by the time the issue was realized.
3. Correct/Intended functionality of the protocol is affected i.e. the snapshooter role assigned to an address cannot ever perform its tasks validly.

### Proof of Concept
Here is the whole process:

1. Snapshooter address calls the [snapshot()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) function. The [onlyFromOwnerOrNamed("snapshooter")](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52) modifier is encountered first.

```solidity
File: TaikoToken.sol
57:     function snapshot() public onlyFromOwnerOrNamed("snapshooter") {
58:         _snapshot();
59:     }
```

2. In the second condition, the [modifier](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L41) calls the [resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L30) function with the "snapshooter" role as `_name` in order to check if the caller (msg.sender) is indeed the address approved by the owner.

```solidity
File: EssentialContract.sol
46:     modifier onlyFromOwnerOrNamed(bytes32 _name) {
47:         if (msg.sender != owner() && msg.sender != resolve(_name, true))
48:             revert RESOLVER_DENIED();
49:         _;
50:     }
```

3. The [resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L30) function is called which internally calls the function [_resolve()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/AddressResolver.sol#L72). In the function _resolve(), the condition on Line 69 evaluates to true and we revert. This is because the addressManager address was never set during initialization using the [__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95) function with the owner and address manager parameters. Due to this, the snapshooter address is denied from performing it's allocated tasks.

```solidity
File: AddressResolver.sol
64:     function _resolve(
65:         uint64 _chainId,
66:         bytes32 _name,
67:         bool _allowZeroAddress
68:     ) private view returns (address payable addr_) {
69:         if (addressManager == address(0)) revert RESOLVER_INVALID_MANAGER();
70:
71:         addr_ = payable(
72:             IAddressManager(addressManager).getAddress(_chainId, _name)
73:         );
74:
75:         if (!_allowZeroAddress && addr_ == address(0)) {
76:             revert RESOLVER_ZERO_ADDR(_chainId, _name);
77:         }
78:     }
```

### Tools Used
Manual Review

### Recommended Mitigation Steps
In the [init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L25) function, consider using the [__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L95) function with the owner and address manager parameters instead of the [__Essential_init()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L109) function with the owner parameter. This would allow the snapshooter address to proceed with taking snapshots as expected.

## [M-02] Banned addresses can invoke/execute message call through retryMessage()

### Impact
When an address is banned, `_message.data` will not be invoked by [_invokeMessageCall()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L477) on the address.

The issue is that if an address is banned while the message STATUS is RETRIABLE, the function [retryMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L310) does not stop the call from executing. This breaks the ban restriction on the address and allows `_message.data` to be invoked on it.

### Proof of Concept

1. Let's say the bridge_watchdog bans an address using function [banAddress()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L101).
- On Line 113, it checks if the address is already banned. If not, set it to true on Line 114.
```solidity
File: Bridge.sol
105:     function banAddress(
106:         address _addr,
107:         bool _ban
108:     )
109:         external
110:         onlyFromOwnerOrNamed("bridge_watchdog")
111:         nonReentrant
112:     {
113:         if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();
114:         addressBanned[_addr] = _ban;
115:         emit AddressBanned(_addr, _ban);
116:     }
```

2. In case of function [processMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L217), the banned address is refunded the Ether and its STATUS is set to DONE. This prevents the function [_invokeMessageCall()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L477) from being called to execute the `_message.data` on the banned address.

```solidity
File: Bridge.sol
301:             // Process message differently based on the target address
302:             if (
303:                 _message.to == address(0) ||
304:                 _message.to == address(this) ||
305:                 _message.to == signalService ||
306:                 addressBanned[_message.to]
307:             ) {
308:                 // Handle special addresses that don't require actual invocation but
309:                 // mark message as DONE
310:                 refundAmount = _message.value;
311:                 _updateMessageStatus(msgHash, Status.DONE);
312:             } else {
```

3. But if the message is already in the RETRIABLE status when the address is banned, the function [retryMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L310) does not stop [_invokeMessageCall()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L477) from being called on Line 368 to execute the `_message.data` on the banned address.

```solidity
File: Bridge.sol
350:     function retryMessage(
351:         Message calldata _message,
352:         bool _isLastAttempt
353:     ) external nonReentrant whenNotPaused sameChain(_message.destChainId) {
354:         // If the gasLimit is set to 0 or isLastAttempt is true, the caller must
355:         // be the message.destOwner.
356:         if (_message.gasLimit == 0 || _isLastAttempt) {
357:             if (msg.sender != _message.destOwner) revert B_PERMISSION_DENIED();
358:         }
359:
360:         bytes32 msgHash = hashMessage(_message);
361:         if (messageStatus[msgHash] != Status.RETRIABLE) {
362:             revert B_NON_RETRIABLE();
363:         }
364:
365:         // Attempt to invoke the messageCall.
366:         
368:         if (_invokeMessageCall(_message, msgHash, gasleft())) {
369:             _updateMessageStatus(msgHash, Status.DONE);
370:         } else if (_isLastAttempt) {
371:             _updateMessageStatus(msgHash, Status.FAILED);
372:         }
373:         emit MessageRetried(msgHash);
374:     }
```


### Tools Used
Manual Review

### Recommended Mitigation Steps
Add a check in function [retryMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L310) to check if the address `_message.to` is banned. If true, refund the Ether and mark the transaction as DONE (or send a signal to retrieve stuck ERC20 tokens on source chain).

## [L-01] Consider initializing ContextUpgradeable contract by calling __Context_init() in TaikoToken.sol

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L25)

ContextUpgradeable is not initialized in TaikoToken.sol contract. This contract is used in ERC20PermitUpgradeable which is used in ERC20VotesUpgradeable. But neither contract initializes this Context contract when the contracts themselves are intialized. 

In TaikoToken.sol [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L25), we can see that the below __Context_init() function is not called.
```solidity
File: ContextUpgradeable.sol
18:     function __Context_init() internal onlyInitializing {
19:     }
20: 
21:     function __Context_init_unchained() internal onlyInitializing {
22:     }
```

## [L-02] Missing address(0) check for USDC in USDCAdapter

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/adapters/USDCAdapter.sol#L38)

It is important to implement this check in init() functions since they can only be called once.

```solidity
File: USDCAdapter.sol
38:     function init(address _owner, address _addressManager, IUSDC _usdc) external initializer {
39:         __Essential_init(_owner, _addressManager);
40:        
41:         usdc = _usdc;
42:     }
```

## [L-03]  __ERC1155Receiver_init() not initialized in ERC1155Vault

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29)

Consider initializing these functions in an init() function in the ERC1155Vault contract.
```solidity
File: ERC1155ReceiverUpgradeable.sol
14:     function __ERC1155Receiver_init() internal onlyInitializing {
15:     }
16: 
17:     function __ERC1155Receiver_init_unchained() internal onlyInitializing {
18:     }
```

## [L-04] srcToken and srcChainId is not updated on old token after migration through changeBridgedToken()

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L73)

When a token is migrated to another token, the old token still points towards the same srcToken and srcChainId as the new token since they are not updated through changeBridgedToken(). 

Due to this external dapps integrating and using these values as reference could run into potential issues. Consider clearing them or changing them to some placeholder data representing the src token and chainId but with a prefix. 
```solidity
File: BridgedERC20.sol
123:     function canonical() public view returns (address, uint256) {
124:         return (srcToken, srcChainId);
125:     }
```

## [L-05] MerkleClaimable does not check if claimStart is less than claimEnd

```solidity
File: MerkleClaimable.sol
90:     function _setConfig(uint64 _claimStart, uint64 _claimEnd, bytes32 _merkleRoot) private {
91:         
92:         claimStart = _claimStart;
93:         claimEnd = _claimEnd;
94:         merkleRoot = _merkleRoot;
95:     }
```

## [L-06] If amountUnlocked in TimelockTokenPool is less than 1e18, rounding down occurs

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/TimelockTokenPool.sol#L197)

If amountUnlocked is less than 1e18, round down occurs. This is not a problem since grants will usually be dealing with way higher values and thus higher unlocking. But this would be a problem for team members or advisors getting maybe 10 taiko or less (in case price of taiko is high). So the more frequent the withdrawing there might be chances of losing tokens due to round down.
```solidity
File: TimelockTokenPool.sol
198:         uint128 _amountUnlocked = amountUnlocked / 1e18; // divide first
```

## [L-07] sendSignal() calls can be spammed by attacker to relayer

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/signal/SignalService.sol#L63)

Since the function is external, an attacker can continuously spam signals to the offchain relayer which is always listening to signals. This would be more cost efficient on Taiko where fees are cheap.

The signals could also be used to mess with the relayer service i.e. by sending a the same signal early by frontrunning a user's bytes32 signal _parameter.
```solidity
File: SignalService.sol
68:     function sendSignal(bytes32 _signal) external returns (bytes32) {
69:         return _sendSignal(msg.sender, _signal, _signal);
70:     }
```

## [L-08] Consider calling Ownable_init() function in constructor to prevent frontrunning of initializer functions are non-approved attackers

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/common/EssentialContract.sol#L65)

Most init functions inheriting from EssentialContract do not implement have restrictions on those functions, which allow anyone to initialize them if not done during deployment. 

Consider calling the function in the constructor and applying the onlyOwner modifier on the init functions.
```solidity
File: EssentialContract.sol
70:     constructor() {
71:         _disableInitializers();
72:     }
```

## [L-09] Add "Zero if owner will process themself" comment to gasLimit instead of fee

In the current code, the preferredExecutor for executing bridged transactions is determined by whether the gasLimit is 0 or not and not the fee.
```solidity
File: IBridge.sol
38:         // Processing fee for the relayer. Zero if owner will process themself. 
39:         uint256 fee;
40:         // gasLimit to invoke on the destination chain.
41:         uint256 gasLimit;
```

## [L-10] Bridge integration issues with swapping protocols

Cross-chain swapping could not occur on chains having long invocation delays since deadline of the swap might expire and become outdated. Consider having custom delays for dapps looking to use bridge. 

```solidity
File: Bridge.sol
459:     /// the transactor is not the preferredExecutor who proved this message.
460:     function getInvocationDelays()
461:         public
462:         view
463:         virtual
464:         returns (uint256 invocationDelay_, uint256 invocationExtraDelay_)
465:     {
466:         if (
467:             block.chainid == 1 // Ethereum mainnet
468:         ) {
469:             // For Taiko mainnet
470:             // 384 seconds = 6.4 minutes = one ethereum epoch
471:             return (1 hours, 384 seconds);
472:         } else if (
473:             block.chainid == 2 || // Ropsten
474:             block.chainid == 4 || // Rinkeby
475:             block.chainid == 5 || // Goerli
476:             block.chainid == 42 || // Kovan
477:             block.chainid == 17_000 || // Holesky
478:             block.chainid == 11_155_111 // Sepolia
479:         ) {
480:             // For all Taiko public testnets
481:             return (30 minutes, 384 seconds);
482:         } else if (block.chainid >= 32_300 && block.chainid <= 32_400) {
483:             // For all Taiko internal devnets
484:             return (5 minutes, 384 seconds);
485:         } else {
486:             // This is a Taiko L2 chain where no deleys are applied.
487:             return (0, 0);
488:         }
489:     }
```

## [L-11] sendMessage() does not check if STATUS is equal to NEW

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L115)

Adding a sanity check would be good to avoid being able to call message that is not in the STATUS = NEW state. This would ensure retriable, recalls and failed txns cannot be repeated again.
```solidity
File: Bridge.sol
119:     function sendMessage(
120:         Message calldata _message
121:     )
122:         external
123:         payable
124:         override
125:         nonReentrant
126:         whenNotPaused
127:         returns (bytes32 msgHash_, Message memory message_)
128:     {
129:         // Ensure the message owner is not null.
130:         if (
131:             _message.srcOwner == address(0) || _message.destOwner == address(0)
132:         ) {
133:             revert B_INVALID_USER();
134:         }
135: 
136:         // Check if the destination chain is enabled.
137:         (bool destChainEnabled, ) = isDestChainEnabled(_message.destChainId);
138: 
139:         // Verify destination chain and to address.
140:         if (!destChainEnabled) revert B_INVALID_CHAINID();
141:         if (_message.destChainId == block.chainid) {
142:             revert B_INVALID_CHAINID();
143:         }
144: 
145:         // Ensure the sent value matches the expected amount.
146:         
148:         uint256 expectedAmount = _message.value + _message.fee;
149:         if (expectedAmount != msg.value) revert B_INVALID_VALUE();
150: 
151:         message_ = _message;
152: 
153:         // Configure message details and send signal to indicate message sending.
154:         message_.id = nextMessageId++;
155:         message_.from = msg.sender; 
156:         message_.srcChainId = uint64(block.chainid);
157: 
158:         msgHash_ = hashMessage(message_);
159: 
160:         ISignalService(resolve("signal_service", false)).sendSignal(msgHash_);
161:         emit MessageSent(msgHash_, message_);
162:     }
```

## [L-12] Protocol does not refund extra ETH but implements strict check 

[See spec here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/IBridge.sol#L105)

The IBridge.sol contract specifies that extra ETH provided when sending a message is refunded back to the user. This currently does not happen since the code implements strict equality check. Using strict equality is better but pointing out the spec described, which would either be followed in the code implemented or the spec should be described properly in the IBridge.sol contract.

```solidity
File: Bridge.sol
146:         uint256 expectedAmount = _message.value + _message.fee;
147:         if (expectedAmount != msg.value) revert B_INVALID_VALUE();
```

## [L-13] If a message is suspended before processMessage() is called, the ERC20 tokens on the source chain and Ether are not refunded.

If a message is suspended before processMessage() is called, the status of the message remains new and the ERC20 tokens on the source and the Ether is locked as well. If the message will never be unsuspended, consider refunding the tokens to the user.
```solidity
File: Bridge.sol
287:         if (block.timestamp >= invocationDelay + receivedAt) {
288:             // If the gas limit is set to zero, only the owner can process the message.
289:             if (_message.gasLimit == 0 && msg.sender != _message.destOwner) {
290:                 revert B_PERMISSION_DENIED();
291:             }
```

## [L-14] User loses all Ether if their address is blacklisted on canonical token

When recalls are made on the source chain using the function recallMessage(), it calls the onMessageRecalled() function on the ERC20Vault contract. The onMessageRecalled() function transfers the ERC20 tokens back to the user along with any Ether that was supplied.

The issue is with this dual transfer where both ERC20 tokens are Ether are transferred to the user in the same call. If the user is blacklisted on the canonical token, the whole call reverts, causing the Ether to be stuck in the Bridge contract.

To understand this, let's consider a simple example:
1. User bridges ERC20 canonical tokens and Ether from chain A to chain B.
2. The message call on the destination chain B goes into RETRIABLE status if it fails for the first time. (**Note: User can only process after invocation delay**).
3. On multiple retries after a while, the user decides to make a last attempt, on which the call fails and goes into FAILED status. 
4. During this time on chain B, the user was blacklisted on the ERC20 canonical token on the source chain.
4. When the failure signal is received by the source chain A from chain B, the user calls recallMessage() on chain A only to find out that although the blacklist is only for the canonical ERC20 token, the Ether is stuck as well. 

## [L-15] onMessageInvocation checks in _invokeMessageCall() can be bypassed to call arbitrary function from Bridge contract

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L490)

The if block requires the data to be greater than equal to 4 bytes, equal to the onMessageInvocation selector and last but not the least for the target address to be a contract.

What an attacker could do to bypass this expected spec is to pre-compute an address for the destination chain and pass it in `_message.to`. He can pass gasLimit = 0 from source to only allow him to process the message on the destination. 

On the destination chain, the attacker can deploy his pre-computed contract address and call processMessage() with it from the constructor. For a chain (L2s/L3s) with no invocation delays, the proving + executing of the message data would go through in one single call.

When we arrive at the isContract check below on the `_message.to` address, we evaluate to false since the size of the contract during construction is 0. Due to this, the attacker can validly bypass the onMessageInvocation selector that is a requirement/single source of tx origination by the protocol for all transactions occurring from the bridge contract. This breaks a core invariant of the protocol.
```solidity
File: Bridge.sol
513:         if (
514:             _message.data.length >= 4 && // msg can be empty
515:             bytes4(_message.data) !=
516:             IMessageInvocable.onMessageInvocation.selector &&
517:             _message.to.isContract()
518:         ) {
519:             success_ = false; 
520:         } else {
521:             (success_, ) = ExcessivelySafeCall.excessivelySafeCall(
522:                 _message.to,
523:                 _gasLimit,
524:                 _message.value,
525:                 64, // return max 64 bytes
526:                 _message.data
527:             );
528:         }
```

## [L-16] Consider reading return value from snapshot() function

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoToken.sol#L52)

The snapshot() function returns a uint256 snapshotId. These ids if retrieved earlier can make the devs life easier when taking multiple timely snapshots.
```solidity
File: TaikoToken.sol
54:     function snapshot() public onlyFromOwnerOrNamed("snapshooter") {
55:         _snapshot();
56:     }
```

## [L-17] One off error in block sync threshold check to sync chain data

The check should be _l1BlockId >= lastSyncedBlock + BLOCK_SYNC_THRESHOLD since threshold is the minimum threshold. 
```solidity
File: TaikoL2.sol
150:         if (_l1BlockId > lastSyncedBlock + BLOCK_SYNC_THRESHOLD) {
151:             // Store the L1's state root as a signal to the local signal service to
152:             // allow for multi-hop bridging.
153:             ISignalService(resolve("signal_service", false)).syncChainData(
154:                 ownerChainId,
155:                 LibSignals.STATE_ROOT,
156:                 _l1BlockId,
157:                 _l1StateRoot
158:             );
```

Same issue here:
```solidity
File: LibVerifying.sol
240:         if (_lastVerifiedBlockId > lastSyncedBlock + _config.blockSyncThreshold) {
241:             signalService.syncChainData(
242:                 _config.chainId, LibSignals.STATE_ROOT, _lastVerifiedBlockId, _stateRoot
243:             );
244:         }
```

## [L-18] Guardian proof that is never fully approved by minGuardians is never deleted

A guardian proof hashs is only deleted if it has been approved by min number of guardians in the approval bits. In case it is not, the approval for the hash remains and is not deleted. 
```solidity
File: GuardianProver.sol
50:         if (approved_) {
51:             deleteApproval(hash);
52:             ITaikoL1(resolve("taiko", false)).proveBlock(_meta.id, abi.encode(_meta, _tran, _proof));
53:         }
```

## [L-19] Consider making the TIMELOCK_ADMIN_ROLE undergo a delay when transferring the admin role

The admin is allowed to skip the delay in operations. But the delay should not be skipped when the role is being transferred.
```solidity
File: TaikoTimelockController.sol
25:     function getMinDelay() public view override returns (uint256) {
26:         return hasRole(TIMELOCK_ADMIN_ROLE, msg.sender) ? 0 : super.getMinDelay();
27:     }
```

## [L-20] One-off error when evaluating deposits to process with the ring buffer size

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibDepositing.sol#L141)

When calculating the deposits to process, we do not want to overwrite existing slots. This is why the last check/condition is implemented.

The issue with the condition is that it is one-off by the max size the ring bugger allows. Since + 1 is already added, make the check < into <= to work to it's full capacity. 
```solidity
File: LibDepositing.sol
148:         unchecked {
149:              
150:             return
151:                 _amount >= _config.ethDepositMinAmount &&
152:                 _amount <= _config.ethDepositMaxAmount &&
153:                 _state.slotA.numEthDeposits -
154:                     _state.slotA.nextEthDepositToProcess <
155:                 _config.ethDepositRingBufferSize - 1;   
156:         }
```

## [L-21] tokenURI() in BridgedERC721 does not conform to EIP-721 specification

### Impact
The BridgedERC721.sol contract is the bridged representation (on chain B) of a canonical token (on chain A). The issue is that the overriden [tokenURI()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107) function in the BridgedERC721 contract does not check whether the `_tokenId` passed as parameter is a valid NFT or not.

Due to this, the ERC721 specification is not conformed to since it requires the tokenURI() function throw/revert if `_tokenId` is not a valid NFT.

```
    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 _tokenId) external view returns (string);
```

It is essential for tokens created on the Bridge level to conform to EIP specifications in order to not break composability with other smart contracts and consumers such as digital marketplaces, block explorers etc. In our case, the [tokenURI()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L107) function would [build and return an EIP-681 URI](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/LibBridgedToken.sol#L43) for a non-existing tokenId, which could be consumed by external applications that require the Bridged token to be EIP-721 compliant.

### Proof of Concept

Below, we can see the difference between the original tokenURI() function that is overriden by the BridgedERC721 contract. On Line 99 in the first snippet, we can see that token existence check is made but when the function was overriden in the second snippet, the check was not applied.

ERC721 tokenURI() function:
```solidity
File: ERC721Upgradeable.sol
098:     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
099:         _requireMinted(tokenId);
100:
101:         string memory baseURI = _baseURI();
102:         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
103:     }
```

BridgedERC721 tokenURI() overriden function:
```solidity
File: BridgedERC721.sol
110:     function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
111:         return string(
112:             abi.encodePacked(
113:                 LibBridgedToken.buildURI(srcToken, srcChainId), Strings.toString(_tokenId)
114:             )
115:         );
116:     }
```

### Tools Used
Manual Review

### Recommended Mitigation Steps
At the start of the function, call the function _requireMinted() to check if the tokenId exists or not.

## [L-22] ERC20Vault and ERC721Vault do not work with all valid ERC20 and ERC721 compliant tokens

### Impact
According to the [README here](https://github.com/code-423n4/2024-03-taiko#additional-context), all vaults are designed to work with all ERC20, ERC721 and ERC1155 tokens, respectively.

The issue is with the ERC20Vault and ERC721Vault contracts which expect canonical tokens to implement the functions name(), symbol() (in case of both ERC20 and ERC721) and decimals() (in case of ERC20 only).

According to the [EIP-20 specification](https://eips.ethereum.org/EIPS/eip-20#methods), functions name(), symbol() and decimals() are OPTIONAL and other contracts (in this case the vaults) **MUST NOT** expect these values to be present.
```solidity
OPTIONAL - This method can be used to improve usability, but interfaces and other contracts MUST NOT expect these values to be present.
```

According to the [EIP-721 specification](https://eips.ethereum.org/EIPS/eip-721#specification), the metadata extension, which includes functions name() and symbol(), is optional.
```solidity
The metadata extension is OPTIONAL for ERC-721 smart contracts
```

Since both the ERC20Vault and ERC721Vault expect these functions to be present by calling them [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L368C1-L370C34) and [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L206C1-L207C35), the calls would revert. This disallows valid ERC-20 and ERC=721 compliant canonical tokens from being bridged.

The issue does not exist in the ERC1155Vualt since it considers for this situation [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L263C1-L268C28) by implementing a try-catch block.

### Proof of Concept

When the function [sendToken()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L207) in the ERC20Vault/ERC721Vault is called by the user, it internally calls function [_handleMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L348). If the `_token` parameter is a canonical token, we enter the else block on Line 376 for ERC20Vault and Line 204 for ERC721Vault.

In the else block, we can see that the functions name(), symbol() and decimals() are directly being called on the canonical token. Since these are optional, the function will revert and prevent users from bridging valid ERC20 and ERC721 compliant tokens.

Function [_handleMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L348) in ERC20Vault:
```solidity
File: ERC20Vault.sol
358:     function _handleMessage(
359:         address _user,
360:         address _token,
361:         address _to,
362:         uint256 _amount
363:     )
364:         private
365:         returns (
366:             bytes memory msgData_,
367:             CanonicalERC20 memory ctoken_,
368:             uint256 balanceChange_
369:         )
370:     {
371:         // If it's a bridged token
372:         if (bridgedToCanonical[_token].addr != address(0)) {
373:             ctoken_ = bridgedToCanonical[_token];
374:             IBridgedERC20(_token).burn(msg.sender, _amount);
375:             balanceChange_ = _amount;
376:         } else {
377:             // If it's a canonical token
378:             IERC20Metadata meta = IERC20Metadata(_token);
379:             ctoken_ = CanonicalERC20({
380:                 chainId: uint64(block.chainid),
381:                 addr: _token,
382:                 decimals: meta.decimals(),
383:                 symbol: meta.symbol(),
384:                 name: meta.name()
385:             });
```

Function [_handleMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC721Vault.sol#L187) in ERC721Vault:
```solidity
File: ERC721Vault.sol
190:     function _handleMessage(
191:         address _user,
192:         BridgeTransferOp memory _op
193:     )
194:         private
195:         returns (bytes memory msgData_, CanonicalNFT memory ctoken_)
196:     {
197:         unchecked {
198:             if (bridgedToCanonical[_op.token].addr != address(0)) {
199:                 ctoken_ = bridgedToCanonical[_op.token];
200:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
201:                     
202:                     BridgedERC721(_op.token).burn(_user, _op.tokenIds[i]);
203:                 }
204:             } else {
205:                 ERC721Upgradeable t = ERC721Upgradeable(_op.token);
206:
207:                 ctoken_ = CanonicalNFT({
208:                     chainId: uint64(block.chainid),
209:                     addr: _op.token,
210:                     symbol: t.symbol(),
211:                     name: t.name()
212:                 });
```

Unlike the two vaults above, the ERC1155Vault considers this case by implementing a try-catch block on Line 286 for the functions name() and symbol().

Function [_handleMessage()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L240) in ERC1155Vault:
```solidity
File: ERC1155Vault.sol
260:     function _handleMessage(
261:         address _user,
262:         BridgeTransferOp memory _op
263:     ) private returns (bytes memory msgData_, CanonicalNFT memory ctoken_) {
264:         unchecked {
265:             // is a btoken, meaning, it does not live on this chain
266:             if (bridgedToCanonical[_op.token].addr != address(0)) {
267:                 ctoken_ = bridgedToCanonical[_op.token];
268:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
269:                     
270:                     BridgedERC1155(_op.token).burn(
271:                         _user,
272:                         _op.tokenIds[i],
273:                         _op.amounts[i]
274:                     );
275:                 }
276:             } else {
277:                 // is a ctoken token, meaning, it lives on this chain
278:                 ctoken_ = CanonicalNFT({
279:                     chainId: uint64(block.chainid),
280:                     addr: _op.token,
281:                     symbol: "",
282:                     name: ""
283:                 });
284:                 IERC1155NameAndSymbol t = IERC1155NameAndSymbol(_op.token);
285:             
286:                 try t.name() returns (string memory _name) {
287:                     ctoken_.name = _name;
288:                 } catch {}
289:                 try t.symbol() returns (string memory _symbol) {
290:                     ctoken_.symbol = _symbol;
291:                 } catch {}
292:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
293:                     IERC1155(_op.token).safeTransferFrom({
294:                         from: msg.sender,
295:                         to: address(this),
296:                         id: _op.tokenIds[i],
297:                         amount: _op.amounts[i],
298:                         data: ""
299:                     });
300:                 }
301:             }
302:         }
```

### Tools Used
Manual Review

### Recommended Mitigation Steps
Similar to the ERC1155Vault, consider implementing a try-catch block for name(), symbol() and decimals() in ERC20Vault and ERC721Vault.

Note that the BridgedERC20 and BridgedERC721 token contracts would need to be updated as well since they currently validate the name and symbol inputs [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC20.sol#L65) and [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC721.sol#L43) to be non-zero values. Since according to the EIP, these values can be empty, the calls on destination would always revert. This issue does not exist in BridgedERC1155 since it uses placeholder data [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L49C1-L52C78) to avoid reverting when a new bridge token is being deployed/created for the canonical token through the vault [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L305).

## [L-23] Guardians cannot be fully removed from the system which can compromise the integrity of the protocol 

### Impact
The end goal of Taiko is to use multiple zkVMs with the guardians removed from the system completely as mentioned [here](https://youtu.be/A6ncZirXPfc?t=2097). The issue is that the guardian roles can never be fully removed due to the address(0) check [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/provers/Guardians.sol#L82) and 5 minGuardians constraint [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/provers/Guardians.sol#L11). This can compromise the integrity and intended spec of the protocol.

### Proof of Concept

When the owner calls the function [setGuardians()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/provers/Guardians.sol#L53) to remove the guardian roles completely, the following happens:
- On Line 66, we ensure that the _newGuardians array length is above the minimum requirement of 5 guardians.
- On Lines 81-84, the old guardians are deleted.
- On Line 90, the check does not allow the new guardians to be zero.
- Due to this, the owner can never remove the guardians since a minimum requirement of 5 is required and the array cannot contain zero addresses.
```solidity
File: Guardians.sol
059:     function setGuardians(
060:         address[] memory _newGuardians,
061:         uint8 _minGuardians
062:     ) external onlyOwner nonReentrant {
063:         // We need at least MIN_NUM_GUARDIANS and at most 255 guardians (so the approval bits fit in
064:         // a uint256)
065:         if (
066:             _newGuardians.length < MIN_NUM_GUARDIANS ||
067:             _newGuardians.length > type(uint8).max
068:         ) {
069:             revert INVALID_GUARDIAN_SET();
070:         }
071:         // Minimum number of guardians to approve is at least equal or greater than half the
072:         // guardians (rounded up) and less or equal than the total number of guardians
073:         if (
074:             _minGuardians < (_newGuardians.length + 1) >> 1 ||
075:             _minGuardians > _newGuardians.length
076:         ) {
077:             revert INVALID_MIN_GUARDIANS();
078:         }
079:
080:         // Delete the current guardians
081:         for (uint256 i; i < guardians.length; ++i) {
082:             delete guardianIds[guardians[i]];
083:         }
084:         delete guardians;
085:
086:         // Set the new guardians
087:         
088:         for (uint256 i = 0; i < _newGuardians.length; ++i) {
089:             address guardian = _newGuardians[i];
090:             if (guardian == address(0)) revert INVALID_GUARDIAN();
091:             // This makes sure there are not duplicate addresses
092:             if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
093:
094:             // Save and index the guardian
095:             guardians.push(guardian);
096:             guardianIds[guardian] = guardians.length;
097:         }
098:
099:         // Bump the version so previous approvals get invalidated
100:         ++version;
101:
102:         minGuardians = _minGuardians;
103:         emit GuardiansUpdated(version, _newGuardians);
104:     }
```

### Tools Used
Manual Review

### Recommended Mitigation Steps
Consider removing the address(0) check. This would require the owner to sanitize the inputs off-chain.

Another solution would be to implement a separate deletion function that deletes the guardianIds mapping and guardians array and sets them to 0.

## [R-01] Consider implementing changeBridgedToken() and btokenBlacklist for ERC721Vault and ERC1155Vault

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L29)

Both vaults are currently missing these two functions. Implementing them is not required but it would be good as a safety net for high-valued NFT collections in emergency scenarios that could arise.

## [R-02] Instead of passing an empty string for the data parameter in NFT vaults on token transfers, allow users to supply data

Allow users to supply the data parameter when transferring tokens from vault to them to ensure any off-chain compatibility/functionality can be built. 
```solidity
File: ERC1155Vault.sol
227:     function _transferTokens(
228:         CanonicalNFT memory ctoken,
229:         address to,
230:         uint256[] memory tokenIds,
231:         uint256[] memory amounts
232:     ) private returns (address token) {
233:         if (ctoken.chainId == block.chainid) {
234:             // Token lives on this chain
235:             token = ctoken.addr;
236:             
237:             IERC1155(token).safeBatchTransferFrom(
238:                 address(this),
239:                 to,
240:                 tokenIds,
241:                 amounts,
242:                 ""
243:             );
```

## [R-03] Use named imports to improve readability of the code and avoid polluting the global namespace

```solidity
File: LibAddress.sol
4: import "@openzeppelin/contracts/utils/Address.sol";
5: import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
6: import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
7: import "@openzeppelin/contracts/interfaces/IERC1271.sol";
8: import "../thirdparty/nomad-xyz/ExcessivelySafeCall.sol";
```

## [N-01] Avoid hardcoding data in BridgedERC1155

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L52)

Instead of hardcoding the data, place it in a constant variable and assign the variables here for better maintainability.
```solidity
File: BridgedERC1155.sol
53:         LibBridgedToken.validateInputs(_srcToken, _srcChainId, "foo", "foo");
```

## [N-02] Missing source()/canonical() function on BridgedERC115 contract

[Link](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/BridgedERC1155.sol#L52)

The BridgedERC1155 contract should implement a similar function to source()/canonical() as done in the other two vaults. This would better for external dapps to retrieve the data much easily.

## [N-03] Using unchecked arithmetic in for loops is handled by solc compiler 0.8.22 onwards

```solidity
File: MerkleTrie.sol
205:     function _parseProof(bytes[] memory _proof) private pure returns (TrieNode[] memory proof_) {
206:         uint256 length = _proof.length;
207:         proof_ = new TrieNode[](length);
208:         for (uint256 i = 0; i < length;) {
209:             proof_[i] = TrieNode({ encoded: _proof[i], decoded: RLPReader.readList(_proof[i]) });
210:             
211:             unchecked {
212:                 ++i;
213:             }
214:         }
215:     }
```

## [N-04] Typo in comment in Bytes.sol

Use rather instead of rathern.
```solidity
File: Bytes.sol
93:     /// @notice Slices a byte array with a given starting index up to the end of the original byte
94:     ///         array. Returns a new array rathern than a pointer to the original.
```

## [N-05] Incorrect comment regarding gasLimit in processMessage()

As confirmed with the sponsor, the comment above the gasLimit variable should be inversed i.e. use gasLeft is called by owner, else gasLimit
```solidity
File: Bridge.sol
307:             } else {
308:                 // Use the specified message gas limit if called by the owner, else
309:                 // use remaining gas
310:             
311:                 uint256 gasLimit = msg.sender == _message.destOwner
312:                     ? gasleft()
313:                     : _message.gasLimit;
```

## [N-06] Use require instead of assert

Use require instead of assert to avoid Panic error, see solidity docs [here](https://docs.soliditylang.org/en/v0.8.25/control-structures.html#panic-via-assert-and-error-via-require).
```solidity
File: Bridge.sol
503:     function _invokeMessageCall(
504:         Message calldata _message,
505:         bytes32 _msgHash,
506:         uint256 _gasLimit
507:     ) private returns (bool success_) {
508:         if (_gasLimit == 0) revert B_INVALID_GAS_LIMIT();
509:         assert(_message.from != address(this)); 
```

## [N-07] Incorrect natspec comment for proveMessageReceived()

Correct first comment on Line 394 to "msgHash has been received"
```solidity
File: Bridge.sol
394:     /// @notice Checks if a msgHash has failed on its destination chain. 
395:     /// @param _message The message.
396:     /// @param _proof The merkle inclusion proof.
397:     /// @return true if the message has failed, false otherwise.
398:     function proveMessageReceived(
399:         Message calldata _message,
400:         bytes calldata _proof
401:     ) public view returns (bool) {
```

## Gas Optimizations

## [G-01] Pack structs tightly to consume less slots and save gas

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoData.sol#L39)

The struct currently uses 8 slots. One slot can be reduced by moving the `uint8 blockSyncThreshold` variable on Line 60 after `uint96 livenessBond; ` on Line 40. This is because variables from Lines 27 to 40 occupying slot 2 only use up 24 bytes, thus more variable of smaller size can be fit into the slot. The reason the last variable can be moved is to ensure the readability of the code due to the comments by the team grouping them. 
```solidity
File: TaikoData.sol
11:     struct Config {
12:         // ---------------------------------------------------------------------
13:         // Group 1: General configs
14:         // ---------------------------------------------------------------------
15:         // The chain ID of the network where Taiko contracts are deployed.
16:         uint64 chainId;
17:         // ---------------------------------------------------------------------
18:         // Group 2: Block level configs
19:         // ---------------------------------------------------------------------
20:         // The maximum number of proposals allowed in a single block.
21:         uint64 blockMaxProposals;
22:         // Size of the block ring buffer, allowing extra space for proposals.
23:         uint64 blockRingBufferSize;
24:         // The maximum number of verifications allowed when a block is proposed.
25:         uint64 maxBlocksToVerifyPerProposal; 
26:         // The maximum gas limit allowed for a block.
27:         uint32 blockMaxGasLimit;
28:         // The maximum allowed bytes for the proposed transaction list calldata.
29:         uint24 blockMaxTxListBytes;
30:         // The max period in seconds that a blob can be reused for DA.
31:         uint24 blobExpiry;
32:         // True if EIP-4844 is enabled for DA
33:         bool blobAllowedForDA;
34:         // True if blob can be reused
35:         bool blobReuseEnabled;
36:         // ---------------------------------------------------------------------
37:         // Group 3: Proof related configs
38:         // ---------------------------------------------------------------------
39:         // The amount of Taiko token as a prover liveness bond
40:         uint96 livenessBond; 
41:         // ---------------------------------------------------------------------
42:         // Group 4: ETH deposit related configs
43:         // ---------------------------------------------------------------------
44:         // The size of the ETH deposit ring buffer.
45:         uint256 ethDepositRingBufferSize;
46:         // The minimum number of ETH deposits allowed per block.
47:         uint64 ethDepositMinCountPerBlock;
48:         // The maximum number of ETH deposits allowed per block.
49:         uint64 ethDepositMaxCountPerBlock;
50:         // The minimum amount of ETH required for a deposit.
51:         uint96 ethDepositMinAmount;
52:         // The maximum amount of ETH allowed for a deposit.
53:         uint96 ethDepositMaxAmount;
54:         // The gas cost for processing an ETH deposit.
55:         uint256 ethDepositGas;
56:         // The maximum fee allowed for an ETH deposit.
57:         uint256 ethDepositMaxFee;
58:         // The max number of L2 blocks that can stay unsynced on L1 (a value of zero disables
59:         // syncing)
60:         uint8 blockSyncThreshold;
61:     }
```

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/TaikoData.sol#L78)

The struct BlockParams can be packed by moving the variables from Lines 85-87 to the start of the struct. This would ensure that the first slot now not only contains a 20-byte address but also three variables totalling 7 bytes.
```solidity
File: TaikoData.sol
80:     struct BlockParams {
81:         address assignedProver;
82:         address coinbase;
83:         bytes32 extraData;
84:         bytes32 blobHash;
85:         uint24 txListByteOffset;
86:         uint24 txListByteSize;
87:         bool cacheBlobForReuse;
88:         bytes32 parentMetaHash;
89:         HookCall[] hookCalls;
90:     }
```

## [G-02] Remove block.coinbase != address(0) check in function onBlockProposed()

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L120)

`block.coinbase` is the L1 block builder, which cannot be a zero address. Consider removing the unnecessary check to save gas.
```solidity
File: AssignmentHook.sol
145:         if (input.tip != 0 && block.coinbase != address(0)) {
146:             address(block.coinbase).sendEther(input.tip);
147:         }
```

## [G-03] Use do-while loop instead of for loop to save gas

[Link to POC](https://www.rareskills.io/post/gas-optimization#viewer-39vpt)

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/team/airdrop/ERC721Airdrop.sol#L59)

```solidity
File: ERC721Airdrop.sol
60:         for (uint256 i; i < tokenIds.length; ++i) {
61:             IERC721(token).safeTransferFrom(vault, user, tokenIds[i]);
62:         }
```

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L90)

```solidity
File: Bridge.sol
101:         for (uint256 i; i < _msgHashes.length; ++i) {
102:             bytes32 msgHash = _msgHashes[i];
103:             proofReceipt[msgHash].receivedAt = _timestamp;
104:             emit MessageSuspended(msgHash, _suspend);
105:         }
```

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L234)

```solidity
File: TaikoL2.sol
259:             for (uint256 i; i < 255 && _blockId >= i + 1; ++i) {
260:                 uint256 j = _blockId - i - 1; 
261:                 inputs[j % 255] = blockhash(j);
262:             }
```

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/provers/Guardians.sol#L74)

```solidity
File: Guardians.sol
83:         for (uint256 i; i < guardians.length; ++i) {
84:             delete guardianIds[guardians[i]];
85:         }
```

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/hooks/AssignmentHook.sol#L172)

```solidity
File: AssignmentHook.sol
192:         for (uint256 i; i < _tierFees.length; ++i) {
193:             if (_tierFees[i].tier == _tierId) return _tierFees[i].fee;
194:         }
```

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibDepositing.sol#L86)

```solidity
File: LibDepositing.sol
099:             for (uint256 i; i < deposits_.length; ) {        
103:                 uint256 data = _state.ethDeposits[
104:                     j % _config.ethDepositRingBufferSize
105:                 ];
106:                 deposits_[i] = TaikoData.EthDeposit({
107:                     
108:                     recipient: address(uint160(data >> 96)),
109:                     amount: uint96(data),
110:                     id: j
111:                 });
112:                 
113:                 
114:                 uint96 _fee = deposits_[i].amount > fee
115:                     ? fee
116:                     : deposits_[i].amount;
117: 
118:                 // Unchecked is safe:
119:                 // - _fee cannot be bigger than deposits_[i].amount
120:                 // - all values are in the same range (uint96) except loop
121:                 // counter, which obviously cannot be bigger than uint95
122:                 // otherwise the function would be gassing out.
123:                 
124:                 unchecked {
125:                     deposits_[i].amount -= _fee;
126:                     totalFee += _fee;
127:                     ++i;
128:                     ++j;
129:                 }
130:             }
```

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProposing.sol#L244)

```solidity
File: LibProposing.sol
284:             for (uint256 i; i < params.hookCalls.length; ++i) {
285:                 if (uint160(prevHook) >= uint160(params.hookCalls[i].hook)) {
286:                     revert L1_INVALID_HOOK();
287:                 }
288: 
289:                 // When a hook is called, all ether in this contract will be send to the hook.
290:                 // If the ether sent to the hook is not used entirely, the hook shall send the Ether
291:                 // back to this contract for the next hook to use.
292:                 // Proposers shall choose use extra hooks wisely.
293:                      
295:                 IHook(params.hookCalls[i].hook).onBlockProposed{
296:                     value: address(this).balance
297:                 }(blk, meta_, params.hookCalls[i].data);
298: 
299:                 prevHook = params.hookCalls[i].hook;
300:             }
```

## [G-04] Instead of accessing `deposits_[i].amount` consider typecasting `data`

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibDepositing.sol#L89C2-L93C85)

Instead of accessing deposits_[i].amount on Lines 113 and 115, consider typecasting `data` to uint96 as done on Line 108 to avoid unnecessary memory reads.
```solidity
File: LibDepositing.sol
105:                 deposits_[i] = TaikoData.EthDeposit({
106:                   
107:                     recipient: address(uint160(data >> 96)),
108:                     amount: uint96(data),
109:                     id: j
110:                 });
111:                 
113:                 uint96 _fee = deposits_[i].amount > fee
114:                     ? fee
115:                     : deposits_[i].amount;
```

## [G-05] Assigning `meta_.txListByteOffset` to 0 not required due to default value being 0

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProposing.sol#L190)

Assigning the variable below to 0 is not required since there are not previous assignments made in the else block [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProposing.sol#L177C1-L192C10) and a value was not for it [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/libs/LibProposing.sol#L132).
```solidity
File: LibProposing.sol
219:             meta_.txListByteOffset = 0; 
```

## [G-06] Cache _newGuardians.length to save gas

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/provers/Guardians.sol#L63C1-L69C10)

Lenght of _newGuardians array is accessed multiple times in the function setGuardians(). Consider caching the value.
```solidity
File: Guardians.sol
65:         if (
66:             _newGuardians.length < MIN_NUM_GUARDIANS ||
67:             _newGuardians.length > type(uint8).max
68:         ) {
69:             revert INVALID_GUARDIAN_SET();
70:         }
71:         // Minimum number of guardians to approve is at least equal or greater than half the
72:         // guardians (rounded up) and less or equal than the total number of guardians
73:         
74:         if (
75:             _minGuardians < (_newGuardians.length + 1) >> 1 ||
76:             _minGuardians > _newGuardians.length
77:         ) {
78:             revert INVALID_MIN_GUARDIANS();
79:         }
```

## [G-07] Instead of assigning guardians.length as guardianId, use i + 1 to save gas

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L1/provers/Guardians.sol#L88)

Line 99 accesses length of storage array guardians on every iteration as it grows. Instead of doing that, use i + 1 to replicate the same behaviour since only one guardian is pushed every iteration.
```solidity
File: Guardians.sol
089:         for (uint256 i = 0; i < _newGuardians.length; ++i) {
090:             address guardian = _newGuardians[i];
091:             if (guardian == address(0)) revert INVALID_GUARDIAN();
092:             // This makes sure there are not duplicate addresses
093:             if (guardianIds[guardian] != 0) revert INVALID_GUARDIAN_SET();
094: 
095:             // Save and index the guardian
096:       
097:             
098:             guardians.push(guardian);
099:             guardianIds[guardian] = guardians.length;
100:         }
```

## [G-08] Consider removing redundant skipFeeCheck() condition

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L141)

The function [skipFeeCheck()](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/L2/TaikoL2.sol#L219) currently returns false as hardcoded. This means that the check is redundant since we always arrive on the second condition in the check below. Consider removing the first condition to save gas.
```solidity
File: TaikoL2.sol
153:         if (!skipFeeCheck() && block.basefee != basefee) {
154:             revert L2_BASEFEE_MISMATCH();
155:         }
```

## [G-09] Remove redundant nonReentrant modifier

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L107)

Reentrancy cannot occur in this function. Additionally, cross-function reentrancy cannot occur as well since function banAddress is restricted to the watchdog. 
```solidity
File: Bridge.sol
110:     function banAddress(
111:         address _addr,
112:         bool _ban
113:     )
114:         external
115:         onlyFromOwnerOrNamed("bridge_watchdog")
116:         nonReentrant 
117:     {
118:         if (addressBanned[_addr] == _ban) revert B_INVALID_STATUS();
119:         addressBanned[_addr] = _ban;
120:         emit AddressBanned(_addr, _ban);
121:     }
```

## [G-10] Consider adding refundAmount > 0 check to save gas on unnecessary sendEther() call

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L299)

In the else block below, consider adding the check `refundAmount > 0` before Line 374. This will save us gas since in most cases the refundAmount would be 0 for most users. This is because refundAmount is only non-zero and assigned [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L275) for special addresses.
```solidity
File: Bridge.sol
368:             if (msg.sender == refundTo) {
369:                 refundTo.sendEther(_message.fee + refundAmount);
370:             } else {
371:                 // If sender is another address, reward it and refund the rest
372:                 msg.sender.sendEther(_message.fee);
373:
374:                 refundTo.sendEther(refundAmount);
375:             }
```

## [G-11] No need to explicitly set success variable to false due to default value being false

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/bridge/Bridge.sol#L495)

In function _invokeMessageCall(), the if block sets success_ to false in the if block if the conditions are met. This is not required since default value of bool is false.
```solidity
File: Bridge.sol
567:             success_ = false; 
```

## [G-12] Consider using if-else block instead of ternary operators

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/libs/LibMath.sol#L12)

```solidity
File: LibMath.sol
14:     function min(uint256 _a, uint256 _b) internal pure returns (uint256) {
15:         return _a > _b ? _b : _a;
16:     }
```

## [G-13] Modifier checks not required on function _verfiyHopProof()

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/signal/SignalService.sol#L206)

The three modifier checks are not required below since the function is called from proveSignalReceived() [here](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/signal/SignalService.sol#L107), which already implements the checks.

```solidity
File: SignalService.sol
217:     function _verifyHopProof(
218:         uint64 _chainId,
219:         address _app,
220:         bytes32 _signal,
221:         bytes32 _value,
222:         HopProof memory _hop,
223:         address _signalService
224:     )
225:         internal
226:         virtual
227:         validSender(_app) 
228:         nonZeroValue(_signal)
229:         nonZeroValue(_value)
230:         returns (bytes32)
```

## [G-14] Cache op.token in function _handleMessage() to save gas

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L249)

`op.token` is accessed multiple times in the function below. Consider caching it to save gas. 
```solidity
File: ERC1155Vault.sol
266:             if (bridgedToCanonical[_op.token].addr != address(0)) {
267:                 ctoken_ = bridgedToCanonical[_op.token];
268:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
269:                  
270:                     BridgedERC1155(_op.token).burn(
271:                         _user,
272:                         _op.tokenIds[i],
273:                         _op.amounts[i]
274:                     );
275:                 }
276:             } else {
277:                 // is a ctoken token, meaning, it lives on this chain
278:                 ctoken_ = CanonicalNFT({
279:                     chainId: uint64(block.chainid),
280:                     addr: _op.token,
281:                     symbol: "",
282:                     name: ""
283:                 });
```

## [G-15] Consider using safeBatchTransferFrom() instead of running a for loop

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC1155Vault.sol#L270)

ERC1155 supports batch transfers. Instead of transferring each tokenId one-by-one, consider batch transferring them to save gas. 

```solidity
File: ERC1155Vault.sol
293:                 for (uint256 i; i < _op.tokenIds.length; ++i) {
294:                     IERC1155(_op.token).safeTransferFrom({
295:                         from: msg.sender,
296:                         to: address(this),
297:                         id: _op.tokenIds[i],
298:                         amount: _op.amounts[i],
299:                         data: ""
300:                     });
301:                 }
```

## [G-16] Add a check on source chain to ensure _op.to is not address(0) or destination vault to save full cross-chain execution gas

[Link to instance](https://github.com/code-423n4/2024-03-taiko/blob/f58384f44dbf4c6535264a472322322705133b11/packages/protocol/contracts/tokenvault/ERC20Vault.sol#L267)

On Line 284, if the `to` address is address(0) or the vault's address, we revert. This causes the user to recall on the source chain to release their associated assets.

A good way to save the execution gas for the whole cross-chain call is to verify the `_op.to` address on the source chain itself in _handleMessage() function. This would prevent both the users and relayers from spending unnecessary gas for the whole call from chain A to chain B and for the user on recall on chain A.
```solidity
File: ERC20Vault.sol
269:     function onMessageInvocation(
270:         bytes calldata _data
271:     ) external payable nonReentrant whenNotPaused {
272:         (
273:             CanonicalERC20 memory ctoken,
274:             address from,
275:             address to,
276:             uint256 amount
277:         ) = abi.decode(_data, (CanonicalERC20, address, address, uint256));
278: 
279:         // `onlyFromBridge` checked in checkProcessMessageContext
280:         IBridge.Context memory ctx = checkProcessMessageContext(); 
281: 
282:         // Don't allow sending to disallowed addresses.
283:         // Don't send the tokens back to `from` because `from` is on the source chain. 
284:         if (to == address(0) || to == address(this)) revert VAULT_INVALID_TO();
285: 
286:         // Transfer the ETH and the tokens to the `to` address
287:         address token = _transferTokens(ctoken, to, amount);
288:         to.sendEther(msg.value);
289: 
290:         emit TokenReceived({
291:             msgHash: ctx.msgHash,
292:             from: from,
293:             to: to,
294:             srcChainId: ctx.srcChainId,
295:             ctoken: ctoken.addr,
296:             token: token,
297:             amount: amount
298:         });
299:     }
```

## [G-17] Avoid returning unnecessary 64 bytes in LibAddress on excessivelySafeCall()

Function sendEther() is one of the most frequently used functions in the bridging functionality. Returning 64 bytes on Line 32 is not required since the return value is not used anywhere. Removing it will save gas since less bytes would be copied to memory.
```solidity
File: LibAddress.sol
22:     function sendEther(address _to, uint256 _amount, uint256 _gasLimit) internal {
23:         // Check for zero-address transactions
24:         if (_to == address(0)) revert ETH_TRANSFER_FAILED();
25: 
26:         // Attempt to send Ether to the recipient address
27:    
28:         (bool success,) = ExcessivelySafeCall.excessivelySafeCall(
29:             _to,
30:             _gasLimit,
31:             _amount,
32:             64, // return max 64 bytes
33:             ""
34:         );
```

## [G-18] Remove redundant string memo field in Message struct to save 1 slot

The string memo field in the struct is not consumed anywhere on the destination bridge contract i.e. neither the bridge itself nor any external application/vault. Removing it will save 1 slot in the struct, thus reducing gas fees on txs. 
```solidity
File: IBridge.sol
17:     struct Message {
18:         // Message ID whose value is automatically assigned.
19:         uint128 id;
20:         // The address, EOA or contract, that interacts with this bridge.
21:         // The value is automatically assigned.
22:         address from;
23:         // Source chain ID whose value is automatically assigned.
24:         uint64 srcChainId;
25:         // Destination chain ID where the `to` address lives.
26:         uint64 destChainId;
27:         // The owner of the message on the source chain.
28:         address srcOwner;
29:         // The owner of the message on the destination chain.
30:         address destOwner;
31:         // The destination address on the destination chain.
32:         address to;
33:         // Alternate address to send any refund on the destination chain.
34:         // If blank, defaults to destOwner.
35:         address refundTo;
36:         // value to invoke on the destination chain.
37:         uint256 value;
38:         // Processing fee for the relayer. Zero if owner will process themself.
39:         uint256 fee;
40:         // gasLimit to invoke on the destination chain.
41:         uint256 gasLimit;
42:         // callData to invoke on the destination chain.
43:         bytes data;
44:         // Optional memo.
45:         string memo; //@audit Gas/NC - redundant memo
46:     }
```

## Analysis Report

## Approach taken in evaluating the codebase

### Time spent on this audit: 21 days (Full duration of the contest)

Day 1
 - Consuming resources provide in the README
 - Understanding and noting down the logical scope

Day 2-7
 - Reviewing base contracts (least inherited)
 - Adding inline bookmarks for notes 
 - Understanding RLP encoding, EIP-4844,

Day 8-12
 - Reviewing core libs such as LibDepositing, Proposing, Verifying, Proving
 - Adding inline bookmarks for problems in libs
 - Gas optimizations for libs

Day 13-14
 - Other L1, L2 contracts for taiko

Day 15-19
 - Reviewing bridge contracts, timelocktokenpool, airdrop contracts

Day 19-21
 - Writing reports 


## Architecture recommendations

### What's unique?
1. Allowing custom processing - Allowing users to take over the processing aspect gives them control over how and when they want to process their messages.
2. On L2s and L2s that have no invocation delays, the team has created an MEV market from the bridge itself since the processing fees are rewarded to the fastest processor.
3. Use to transient storage - The team has used TSTORE and TLOAD in two places. One is to enable cheaper reentrancy locks and the second is to provide external applications with context. Having context is important since it allows anyone e.g. the vaults to verify whether the source sending the transactions is valid.

### What's using existing patterns and how this codebase compare to others I'm familiar with
 - Comparing Taiko to Starknet, the taiko model is much superior since it takes Ethereum's security and uses it to provide cheaper fees to user. The risk associated with Taiko is lesser as well even though it is a type-1 zkevm. This is because Taiko uses guardians while Starknet implements escape hatches, which are more centralized.

## Centralization risks

### Actors Involved and their roles

1. The biggest trust assumption in the contract is the owner role handling all the Address manager contracts. This role can pause the contracts at anytime.
2. The second trust assumption is the guardians multisig. Currently, the guardians are trusted and will be removed over time. But since they are the highest tier, the centralization risk in the proving system exists.
3. ANother role is the bridge watchdog. This role can ban and suspend any messages at will. It is the most important risk of the bridge contracts.
4. The snapshooter role has some risks associated since it takes snapshots on the TaikoToken.

There are more roles in the codebase but these are the foremost and most central to the protocol.

## Resources used to gain deeper context on the codebase

1. Based Rollups and decentralized sequencing
  - [Understanding the Concept of Based Rollups](https://ethresear.ch/t/based-rollups-superpowers-from-l1-sequencing/15016)
  - [Based Rollup FAQ](https://taiko.mirror.xyz/7dfMydX1FqEx9_sOvhRt3V8hJksKSIWjzhCVu7FyMZU)
  - [X space - Part 1](https://www.youtube.com/watch?v=eS5s08sgjuo)
  - [X space - Part 2](https://www.youtube.com/watch?v=RqgIEkAfpks)

2. Based Contestable Rollup (BCR)
  - [Understanding the concept of Based Contestable Rollup](https://taiko.mirror.xyz/Z4I5ZhreGkyfdaL5I9P0Rj0DNX4zaWFmcws-0CVMJ2A)
  - [Based Contestable Rollup 101](https://www.youtube.com/watch?v=A6ncZirXPfc)

3. Protocol Documentation
  - [Website Docs](https://docs.taiko.xyz/core-concepts/what-is-taiko/)
  - [Markdown concept-specific docs](https://github.com/code-423n4/2024-03-taiko/blob/main/packages/protocol/docs)

## Mechanism Review

### Protocol Goals

![Imgur](https://i.imgur.com/eWUK7d5.png)

### High Level System Overview

![Imgur](https://i.imgur.com/C2NE56L.png)

### Understanding Taiko BCR

1. Taiko has no sequencer - block builders/sequencing is decided by Ethereum validators. Permissionless block proposing, building and proving of taiko blocks. Since it uses what Ethereum has to provide (the market of proposers/builders) to its advantage and is not reinventing the wheel, Taiko is "based".

2. Why do we need contestable rollups?

Although ZK is the future, it does introduce complexity in the implementation of the system and thus the chances of bugs. There might be a small % of proofs that are invalid but can still be verified onchain. As a protocol designer, Taiko has to handle these small odds. No validity proof can be trusted without battle testing in short. A malicious block proposer (since proposing blocks is permissionless) can bundle a lot of transactions in a block and create an invalid proof, which would not be handleable by the MerkleTrie verification system. This is why contestable rollups are introduced to prevent these kind of situations/attacks. 

Due to this since not all blocks are ZK-provable (block gas limit <> ZK constraint limit), Taiko introduced the guardian role to override invalid proofs. 

Another reason why this tier-based contestable rollup design is used is in case, app chains, other layer 2s and layer3s want to use different proof systems other than ZK (so opt out of ZK proofs and maybe opt into SGX proof a.k.a Optimistic proofs).

3. How the guardian will be chosen

DAO => Security Council (owner of all smart contracts) => security council is a multisig with a lot of actors not only from taiko but also the community (like token holders) => security council will decide who will be the guardians => guardian is the multisig smart contract onchain => each guardian will have to run their own full node => each guardian works independently and they do not need to reach consensus offchain => they independently correct the wrong onchain => if the aggregated approval onchain is greater than let's say 2/3rd of the guardians, then the previous proof is overwritten by the guardian to make sure the network is on the right path and has the right state.

This guardian proving should be really rare since there is this taiko token-based bond design i.e. validity bond which will be burnt if the proof is re-proven to be incorrect or they have the contestation bond i.e. if you contest a proof and it ends up that the original proof is correct and you are wrong, then your contestation bond is burnt. 

This prevents people from spamming the network (unless they want to burn bonds, which is dumb).

Eventually, after the best tier i.e. highest tier proof (ZK proof) is solid and battle-tested and is really bug free, then the guardian provers should be gone since it's really just for the training wheel.

4. Benefits of Based Contestable Rollup

 - Abstraction of special if-else code into a tier-based proof system makes the developers aware that the team cannot just shut down the chain uasing guardian prover and does not have control over it.
 - Taiko has 3 types of bonds - validity bonds, contestation bonds and liveness bonds. We've spoken about the first two. Liveness bonds are basically, le's say, I have a prover off-chain and this prover is supposed to submit the proof within 15 minutes, then if the prover does not submit the proof in that time, then the prover's liveness bond is burnt. 
 - As an app dev, you can always change your config a long way. You can just use one layer-1 transaction to go from 100% optimistic to 100% ZK rollup. 
 - As ZK becomes more trustworthy, the team will slowly increase the % to ZK unitl they become fully ZK and remove the guardian prover. 

5. Cooldown window for validity proofs

Since we know ZK is not fully trustworthy, let's give it 2-3 hours, so that if nobody challenges this ZK proof, it is final. So from that perspective, Taiko always allows validity proofs to be challenged and overwritten with a higher-tier proof. This adds security. 

6. Another Benefit of Based Contestable Rollup

If someone says "I don't like the contestable feature", they can always configure their rollup with only one (top) tier. Then all proofs are not contestable and final. No validity bond nor contestable bond applies. 

7. Taiko Mainnet Proofs

Initially: Optimistic => SGX => PSE zkEVM => Guardians

Later: Optimistic => SGX => PSE zkEVM => zkVM (risc0) => Guardians

End game: multiple zkVMs (Guardians removed)

### Chains supported

 - Ethereum
 - Taiko L2s/L3s

### Grouping of Core Contracts

![Imgur](https://i.imgur.com/HMD27NM.png)

### Recall specific scenario

![Imgur](https://i.imgur.com/cHzS1vH.png)

## Systemic Risks/Architecture-level weak spots and how they can be mitigated

There are a few risks associated with the protocol:
 - The protocol does not have a robust on-chain fee estimation mechanism. On calling the on-chain functions, the relayers should provide the contracts with upto date prices for users or atleast maintain a default amount of gas to send across.
 - The protocol would not work perfectly with swapping protocols. This is because the bridge includes invocation delays which can cause swaps to go outdated.
 - There is an issue related to custom coinbase transfers which can create a risk among block proposers.
